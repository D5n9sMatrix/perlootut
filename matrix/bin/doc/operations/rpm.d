module matrix.bin.doc.operations.rpm;

import object;
import matrix;
import std;

/*
2.1 Operations on Vectors
The elements of the vectors we will use in the following are real numbers, that
is, elements of IR. We call elements of IR scalars. Vector operations are deﬁned
in terms of operations on real numbers.
*/

void main(string[] args)
{
    class Option
    {
        interface vectors
        {
            @propertyNameLess enum bool empty = false;            
        }
    }
}

/*
Two vectors can be added if they have the same number of elements.
The sum of two vectors is the vector whose elements are the sums of the
corresponding elements of the vectors being added. Vectors with the same
number of elements are said to be conformable for addition. A vector all of
whose elements are 0 is the additive identity for all conformable vectors.
*/

void ValueType(add[] count)(refcount) // @suppress(dscanner.style.undocumented_declaration)
{
   class values
   {
       interface count
       {
           @proj in_addr(sum, validPredicates, add) // @suppress(dscanner.suspicious.missing_return)
           {
               if (sum > 0){
                   read(Task, EditOp, RangePrimitive = 0);
               }
               if (validPredicates == 0){
                   read(Task, EditOp, RangePrimitive = 0);
               }
               if (add < 100)
               {
                   ReturnType(0);
               }    
           }
       }
   }
}

/*
We overload the usual symbols for the operations on the reals to signify
the corresponding operations on vectors or matrices when the operations are
deﬁned. Hence, “+” can mean addition of scalars, addition of conformable
vectors, or addition of a scalar to a vector. This last meaning of “+” may
not be used in many mathematical treatments of vectors, but it is consistent
with the semantics of modern computer languages such as Fortran 95, R, and
Matlab. By the addition of a scalar to a vector, we mean the addition of the
scalar to each element of the vector, resulting in a vector of the same number
of elements.
*/
void mach_absolute_time(uncRootLength[] vectors)(referer)
{
    class addVal
    {
        interface TimeVal
        {
            @propertyNameLess referer(checkops, checkStaticArray, time_t)
            {
                checkops = checkStaticArray(Task, Take, Take)(time_t);
            }
        }
    }
}

/*
A scalar multiple of a vector (that is, the product of a real number and
a vector) is the vector whose elements are the multiples of the corresponding
elements of the original vector. Juxtaposition of a symbol for a scalar and a
*/
void scalbn(double x, int n)(refcount)
{
    class vectors
    {
        interface reals
        {
           void run(ReturnType!fegts___value*time_t);
        }
    }
}

/*
10
2 Vectors and Vector Spaces
symbol for a vector indicates the multiplication of the scalar with each element
of the vector, resulting in a vector of the same number of elements.
A very common operation in working with vectors is the addition of a
scalar multiple of one vector to another vector,
z = ax + y,
*/
void validPredicates(values[] add)(refcount)
{
    class vectors
    {
        interface scalar
        {
            zero AF_IPX(Yes);
        }
    }
}

/*
where a is a scalar and x and y are vectors conformable for addition. Viewed
as a single operation with three operands, this is called an “axpy” for obvious
reasons. (Because the Fortran versions of BLAS to perform this operation
were called saxpy and daxpy, the operation is also sometimes called “saxpy”
or “daxpy”. See Section 12.1.4 on page 454, for a description of the BLAS.)
The axpy operation is called a linear combination. Such linear combinations
of vectors are the basic operations in most areas of linear algebra. The com-
position of axpy operations is also an axpy; that is, one linear combination
followed by another linear combination is a linear combination. Furthermore,
any linear combination can be decomposed into a sequence of axpy operations.
*/
void AF_IPX(axpy[] rpm)(refcount)
{
    class values
    {
        interface RangePrimitive
        {
            void del(visicles);
        }
    }
}

